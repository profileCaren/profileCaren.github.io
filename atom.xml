<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Caren&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://laijiawen.com/"/>
  <updated>2018-11-20T11:03:38.000Z</updated>
  <id>http://laijiawen.com/</id>
  
  <author>
    <name>Jiawen Lai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何实现 JavaScript 的 new 运算符</title>
    <link href="http://laijiawen.com/posts/implement-new-indentifier-of-javascript/"/>
    <id>http://laijiawen.com/posts/implement-new-indentifier-of-javascript/</id>
    <published>2018-11-20T11:03:38.000Z</published>
    <updated>2018-11-20T11:03:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近期在二刷高程(《JavaSript 高级程序设计》)，书中提及了<code>new</code>运算符做的事情，我联想到似乎不少面试总结文章都有提及这一问题，故深入研究了一下，在此简要记录。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我先写一段代码，本文将基于这段代码进行讲解。<br>在这段代码中，我们先实现两个<strong>构造函数</strong>，分别是<code>Person</code>和<code>Animal</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">type, name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = type;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> caren = <span class="keyword">new</span> Person(<span class="string">&quot;Caren&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="keyword">let</span> doggy = <span class="keyword">new</span> Animal(<span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;doggy&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(caren); <span class="comment">// &#123; name: &quot;Care&quot;, age: 22&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(caren <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doggy); <span class="comment">// &#123;type: &#x27;Dog&#x27;, name: &quot;doggy&quot;, age: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(doggy <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>现在请读者来花一分钟思考一下 <code>new</code>运算符做了什么事情。</p><h2 id="new-运算符做了什么"><a href="#new-运算符做了什么" class="headerlink" title="new 运算符做了什么"></a>new 运算符做了什么</h2><p>本文不会像大多数网上的文章一样一下子就给出结论。要回答这个问题，我们得有一个思考的过程。这个过程其实很简单，只需要对比普通的执行方式以及通过<code>new</code>的执行方式的执行结果区别即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通调用方式，如果是在浏览器调用的话，会直接给`window`对象增加两个全局变量`name`以及`age`，</span></span><br><span class="line"><span class="comment">// 返回的`caren`是`undefined`；</span></span><br><span class="line"><span class="keyword">let</span> caren1 = Person(<span class="string">&quot;Caren&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(caren1); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而通过`new`调用，则会新建一个 Person 对象，并设置这个对象的`name`和`age`属性为对应参数，</span></span><br><span class="line"><span class="comment">// 返回的`caren`是这个新对象。</span></span><br><span class="line"><span class="keyword">let</span> caren2 = <span class="keyword">new</span> Person(<span class="string">&quot;Caren&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(caren2); <span class="comment">// &#123;name: &quot;Caren&quot;, age: 22&#125;</span></span><br></pre></td></tr></table></figure><p>通过对比，显然<code>new</code>做了至少以下四件事：</p><ol><li>新建了一个对象。</li><li>将<code>new</code>运算符后面的构造函数的作用域指向这个新对象。(将构造函数的<code>this</code>指向新对象)</li><li>执行<code>new</code>后面的构造函数。</li><li>返回新对象。</li></ol><p>其实不止，注意我们第一段代码中<code>instanceof</code>的调用，它能够判断出这个<code>new</code>出来的<code>caren</code>是<code>Person</code>的实例，实现这四步还无法做到这一点（对象的识别）。为了实现对象的识别，还需要理解<code>instanceof</code>是如何进行判断的。</p><h3 id="instanceof-是如何进行判断的"><a href="#instanceof-是如何进行判断的" class="headerlink" title="instanceof 是如何进行判断的"></a>instanceof 是如何进行判断的</h3><p>这个问题略为复杂，可以看看 IBM 的这篇<a href="https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/index.html">《JavaScript instanceof 运算符深入剖析》</a>深入了解一下，在此简要总结如下：</p><p><code>instanceof</code>通过不断“往上”地查找实例的原型(<code>__proto__</code>)，判断其是否与<code>instanceof</code>运算符右侧的构造函数的原型（<code>prototype</code>）相等。只要原型链中有一个原型对象满足条件，则返回<code>true</code>。</p><p>实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//L 表示左表达式，R 表示右表达式</span></span><br><span class="line">  <span class="keyword">var</span> O = R.prototype;</span><br><span class="line">  L = L.__proto__;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (O === L) &#123;</span><br><span class="line">      <span class="comment">// 这里重点：当 O 严格等于 L 时，返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L = L.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://caren-1253602298.cos.ap-guangzhou.myqcloud.com/emmm.jpg" alt="emmm"></p><blockquote><p>“为什么你这段话每个字我都看得懂，连起来就不懂呢？”</p></blockquote><p>基础不那么扎实的同学看到这里可能有点恍惚，想关掉浏览器，我们有必要先复习一下原型的知识。</p><h3 id="原型简单复习"><a href="#原型简单复习" class="headerlink" title="原型简单复习"></a>原型简单复习</h3><p>在这里我也不想直接放网上那个知名的图：</p><p><img src="https://caren-1253602298.cos.ap-guangzhou.myqcloud.com/prototype-chain.jpg" alt="原型链图"></p><p>不然读者可能要打我：</p><blockquote><p>本来很简单一个问题，你搞这么复杂干什么？拉黑了。</p></blockquote><p>我就简单描述一下，要理解原型，理清楚三个东西之间的关系就好了：</p><ol><li><strong>实例对象</strong>。即<code>new</code>出来的对象。</li><li><strong>构造函数</strong>。一般也称为类。即上文的<code>Person</code>和<code>Animal</code>对象。</li><li><strong>构造函数的原型</strong>。我们创建的每个函数，都会自动生成一个<code>prototye</code>属性，这个属性是一个指针，指向一个对象。这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</li></ol><p>我们先不管实例对象，先看构造函数和它的原型之间的关系：</p><p><img src="https://caren-1253602298.cos.ap-guangzhou.myqcloud.com/person%26persons_prototye.jpg" alt="构造函数和构造函数的原型之间的关系"></p><p>很简单，每个函数被创建之后，都会自动创建一个对应的原型对象，并且这个函数都有一个<code>prototype</code>属性，指向这个原型对象。与此同时，原型对象也有一个<code>constructor</code>指针指回构造函数。以上文的<code>Person</code>为例，创建完<code>Person</code>以后，<code>Person.prototye</code>这个对象也会被自动创建，它有一个<code>constructor</code>属性指向<code>Person</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor.prototype.constructor === Person; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>接着我们加入实例对象：<br><img src="https://caren-1253602298.cos.ap-guangzhou.myqcloud.com/prototype-chain-me.jpg" alt=""></p><p>没错，实例对象<code>caren</code>会有一个<code>__proto__</code>属性指向构造函数的原型。</p><p>接下来我们再看<code>instanceof</code>的实现就很好理解了，不赘述。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//L 表示左表达式，R 表示右表达式</span></span><br><span class="line">  <span class="keyword">var</span> O = R.prototype; <span class="comment">// 取 构造函数 R 的原型对象</span></span><br><span class="line">  L = L.__proto__; <span class="comment">// 取 L 实例对象的原型对象</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (L === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (O === L) &#123;</span><br><span class="line">      <span class="comment">// 这里重点：当 O 严格等于 L 时，返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L = L.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance_of(caren, Person)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="new-运算符的实现"><a href="#new-运算符的实现" class="headerlink" title="new 运算符的实现"></a>new 运算符的实现</h2><p>我们讲了半天的 <code>instanceof</code> 其实是为了说明，为了解决对象的识别问题，我们还需要将这个新建的对象加到原型链上。故除了上文描述的四步，还需要增加一步——设置对象的原型：</p><ol><li>新建了一个对象。</li><li><strong>设置该对象的原型(<code>__proto__</code>)为构造函数的原型(<code>prototype</code>)</strong></li><li>将<code>new</code>运算符后面的构造函数的作用域指向这个新对象。(将构造函数的<code>this</code>指向新对象)</li><li>执行<code>new</code>后面的构造函数</li><li>返回新对象</li></ol><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p>目标是实现一个<code>mockNew</code>函数，调用效果如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = mockNew(Animal, <span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;doggy&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> caren = mockNew(Person, <span class="string">&quot;Caren&quot;</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>第一个参数是构造函数，后面为构造函数接收的参数，具体实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mockNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 新建对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> _constructor = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 设置对象的原型， 注意对着上文的图看。</span></span><br><span class="line">  obj.__proto__ = _constructor.prototype;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3/4. 利用 apply 调用构造函数</span></span><br><span class="line">  _constructor.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 返回这个对象</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一个小细节是，我们调用了 <code>[].shift.call(arguments)</code> 来获取第一个参数，即构造函数，这个调用会顺便将之移出<code>arguments</code>“数组”。因而<code>arguments</code>数组只剩下构造函数想要的参数。<br>如<code>arguments</code>原本是<code>[Animal, &quot;Dog&quot;, &quot;doggy&quot;, 10]</code>，调用完后变成<code>[&quot;Dog&quot;,&quot;doggy&quot;,10]</code>。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://codepen.io/caren11/pen/yQbvGN?editors=0012">codepen</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文先通过一个例子的对比，说明<code>new</code>运算符背地里干了四件事情，但仅仅那四件事情无法解决对象的识别问题——即通过<code>instanceof</code>运算符获得正确结果。为了解决这一问题，我们需要探究了<code>instanceof</code>运算符的工作原理，在这一过程中，为了更清楚地讲述，我们还复习了原型链的相关知识。最后我们得到结论并实现了<code>new</code>运算符。</p><p>希望希望对读者有所帮助，表达若有欠缺或者描述不清楚的地方欢迎指正。</p><p>欢迎评论:D</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;近期在二刷高程(《JavaSript 高级程序设计》)，书中提及了&lt;code&gt;new&lt;/code&gt;运算符做的事情，我联想到似乎不少面试总结文
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://laijiawen.com/tags/JavaScript/"/>
    
      <category term="前端" scheme="http://laijiawen.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>当我拔牙的时候我在想什么</title>
    <link href="http://laijiawen.com/posts/what-was-I-thinking-when-I-was-pulled-out-ouf-my-teeth/"/>
    <id>http://laijiawen.com/posts/what-was-I-thinking-when-I-was-pulled-out-ouf-my-teeth/</id>
    <published>2018-11-13T10:59:28.000Z</published>
    <updated>2018-11-13T10:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ol><li>医生你这是虎口拔牙我跟你说。</li><li>嗯..我好像属鼠，鼠口拔牙我跟你说。</li><li>据说想点别的东西就不会害怕。</li><li>完了你这样扯我的嘴巴，法令纹肯定要加深了。</li><li>刚刚我好像被对比原理骗了，价格表上的价格肯定是假的，骗我说打折。</li><li>不过这里确实高端，价格高应该有他的道理。这个手术室比我客厅还大，利用率还不到 50%。</li><li>居然还有个助手，还是很专业的。</li><li>完了这是禀赋效应，差点被自己骗了，我得想想这为啥不值得。</li><li>你这样说，我嘴巴肯定被你撕裂了。</li><li>诶我昨天，第一次在女生床上呆了接近一个小时，竟然是在挂蚊帐。</li><li>那时傻逼国乐还打电话来，我说我在女生床上没空理你，他很识趣的挂了电话。</li><li>等会我要写一篇《当我在拔牙的时候我在想什么》，我得注意一下接下来的想法。</li><li>别吧我的法令纹，拔个牙老五岁。</li><li>我的鼻毛可能被你看到了 这个角度。</li><li>现代医学真是厉害，麻醉打下去，这牙拔的我一点感觉都没有。</li><li>这红色的眼镜真的能护眼吗，不是一般防蓝光的吗。不过戴上去确实舒服一点。</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文存在于我小米 Mix2s (有广告嫌疑)的便签当中，记录于两个月前，今天回看发现发人深省，于是把它简单记录到博客，已警示后来者。</p><p>可以看到，只是去拔个牙而已，整个被骗过程竟然着蕴含着“<a href="/posts/how-to-avoid-being-brainwashed-part-1/" title="对比原理">对比原理</a>”、“<a href="https://zh.wikipedia.org/zh-hans/%E7%A6%80%E8%B5%8B%E6%95%88%E5%BA%94">禀赋效应</a>”等等多个心理学原理。这个故事告诉我们，一定要多了解心理学，不然就会被骗去(用很高的价格)拔牙。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正文&quot;&gt;&lt;a href=&quot;#正文&quot; class=&quot;headerlink&quot; title=&quot;正文&quot;&gt;&lt;/a&gt;正文&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;医生你这是虎口拔牙我跟你说。&lt;/li&gt;
&lt;li&gt;嗯..我好像属鼠，鼠口拔牙我跟你说。&lt;/li&gt;
&lt;li&gt;据说想点别的东西就不会害
      
    
    </summary>
    
    
      <category term="心理学" scheme="http://laijiawen.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="思考" scheme="http://laijiawen.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>对 Gmail 创始人 Paul Buchheit 的访谈摘录</title>
    <link href="http://laijiawen.com/posts/Extract-from-the-interview-with-gmail-creator-and-y-combinator-partner-paul-buchheit/"/>
    <id>http://laijiawen.com/posts/Extract-from-the-interview-with-gmail-creator-and-y-combinator-partner-paul-buchheit/</id>
    <published>2018-11-02T10:57:44.000Z</published>
    <updated>2018-11-02T10:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TripleByte 对 Gmail 创始人 Paul Buchheit 的进行了一个访谈，访谈内容很不错，我看完原文后获益匪浅，故在此做摘录以作备忘。</p><h1 id="关于成为一名程序员"><a href="#关于成为一名程序员" class="headerlink" title="关于成为一名程序员"></a>关于成为一名程序员</h1><p><strong>1. How did you start programming?</strong></p><p>One moment I remember really getting into programming came while playing a fantasy RPG video game. I got stuck and couldn’t find the magic handcuffs—or whatever it was—that I needed. Then I thought, “maybe instead of searching in the game, I can just hack the data file where it saves the inventory!” I started writing programs to figure out how the game was storing things. Then I figured out how to insert anything into my inventory, including things that didn’t even exist in the game.</p><p>That’s when I realized wow, this is way more fun than the actual game. With games you’re just trapped inside someone else’s world. But with programming, you can do anything you want to the world, right? It’s an open environment, and there’s no limit to what you can do. <strong>From then on, video games just seemed like a pointless waste of time compared to programming.</strong></p><p><em>大神之所以成为大神，是因为他们兴趣于此，而不是因为他们有多努力。</em></p><h1 id="关于加入-Google-以及创造-Gamil"><a href="#关于加入-Google-以及创造-Gamil" class="headerlink" title="关于加入 Google 以及创造 Gamil"></a>关于加入 Google 以及创造 Gamil</h1><p><strong>1. Why did you decide to leave Intel?</strong></p><p>Overall, the job wasn’t exciting to me. I didn’t have to work that hard, and one day I had this realization while sitting in my gray cubicle (I was in a sea of gray cubicles surrounded by gray walls, listening to white noise and all alone): I’m like, “Man I am so tired. I need to go home and take a nap.” I went home, but as soon as I got there I realized, “I’m not tired anymore.” Working at Intel was a draining environment, and I knew I wanted to leave.</p><p><em>大神就是任性啊，一瞬间的疲累就让他想要辞职了，都不愁吃喝不愁房贷的。</em></p><p><strong>2. How did you manage your personal career progression at Google?</strong></p><p>I’ve never really been into the whole “career” thing. It just feels horribly big-company. I was always very allergic to things that I perceived as big company. I just didn’t want to be tucked away in a corner working on something irrelevant. I interned at Microsoft after my freshman year of college. On my last day, one of the smartest engineers in my group gave me this piece of advice, “<strong>Make sure they don’t stick you off in a corner working on something unimportant.</strong>” I’ve always remembered it as good advice. My ambition at Google was just to launch a cool product or create something important.</p><p><em>大神从来不做职业规划，随心而行，牛逼。</em><br><em>那个微软的大神的话也值得一提：（当你在大公司工作的时候）Make sure they don’t stick you off in a corner working on something unimportant.</em></p><h1 id="关于如何成为一个伟大的工程师"><a href="#关于如何成为一个伟大的工程师" class="headerlink" title="关于如何成为一个伟大的工程师"></a>关于如何成为一个伟大的工程师</h1><p><strong>1. What skills and knowledge does it take to be a good engineer?</strong></p><p>Computer science is almost unlike any other engineering discipline because we routinely work at many different layers of abstraction. Someone who is only able to operate at one level is not going to be effective because often any given problem will be at a different level of abstraction from the last. Great engineers understand computers all the way from the silicon up through the different layers and protocols and systems.</p><p><em>确实，要解决一个复杂问题，可能要面对多个抽象层，我们光会点 JS/CSS 实在是太局限了。要对一些计算机的底层原理有更细致的了解才行，于前端工程师而言，则 HTTP 是必须要精通的。这个话题从更大的角度来说，就是不要将自己局限于前端工程师这个 title，而要将自己想象成解决问题的工程师。这也是我前段时间才领悟到的一句话，改日再写一篇文章仔细论述。</em></p><p><strong>2. How do you become a better engineer?</strong></p><p>Doing it. Showing up seems to be the secret to getting good at most things. I programmed when I was in high school, and it was all I did because I didn’t have anything else going on—fortunately. Programming was my hobby, and I always had some project I was trying to implement. I think there’s no substitute for doing a lot of programming because you just can’t get really good in a short amount of time. It certainly took me years before I would say I was any good.</p><p><em>兴趣啊兴趣啊，其实每个工程师都会有一点自己的小 ideas 想要做的吧。有没有执行力去完成它则是另一回事。</em></p><p><strong>3. Who are some of the best engineers you’ve worked with? What made them great?</strong></p><p>One of the most impressive engineers I ever worked with is Bret Taylor who was also my co-founder at FriendFeed. I’ve never encountered anyone else who combines being an incredible engineer, and being an incredible product person, and an incredible manager, and an incredible designer. He is good at everything—it’s unfair!</p><p>The story about Bret I most vividly remember is from our days at Google. He wasn’t even an engineer there, instead he was a product manager for some reason. As the PM on Google Maps, he was frustrated that the JavaScript was really slow. It would take forever to load. <strong>So, one weekend he said, “I’m going to rewrite it”. And he rewrote the entire thing, making it 10 times as fast and a third of the size.</strong> He completely threw away the code that a team of engineers had been working on for months. Someone who can do that is ridiculous. Talk about 10x engineers. That’s more like 1000x. And it’s good, clean code too. Literally no number of median engineers can do that. You can give me a million median engineers and they would never be able to do that. They would just make a huge mess.</p><p>Craig Silverstein was another, he was the very first Google employee. He is someone who types and programs faster than I can perceive what he’s doing. Sometimes I like to watch other engineers work so I can learn how they do things. But with Craig he moved too fast for that. The screen would flicker and code would just appear. He’d constantly be flipping buffers in Emacs or whatever. He types so fast. I’ve never seen anyone else that fast.</p><p><em>Bret Taylor 一个人重写了一整个工程师队伍写了数月的 Google Maps, 并提升了接近十倍的速度，减少了三分之二的文件大小。一个字，强。Google 了一下他，发现他后来成了 Facebook 的 CTO. 牛逼。</em></p><h1 id="关于离开谷歌并加入一个创业公司"><a href="#关于离开谷歌并加入一个创业公司" class="headerlink" title="关于离开谷歌并加入一个创业公司"></a>关于离开谷歌并加入一个创业公司</h1><p><strong>1. If the hours and the pay are worse, what are the benefits of working at a startup?</strong></p><p>A big company, like Google is today, has all these really smart people who are already experienced and know what they’re doing. So, if you join Google, you’re going to be working at your “correct” level. At a startup, though, they probably don’t have the resources they need, so you can be operating way beyond your level. That’s what I think is really great about startups.</p><p>Gmail is an example of this. I was 24 years old at the time, and I’d never completed a project of that scale or built anything like that before. Google today would never give that project to a relatively inexperienced 24 year old. But at a startup you can end up getting a project that a more mature company would give to a more experienced engineer.</p><p><em>这里说的是在小公司工作的好处，大公司有大量的牛人，所以你去到那只会做你这个 level 做的事情，比如做个小前端。但是创业公司不同，你可能会接触到各个层次 level 的东西。Paul 说他当年做 Gmail 的时候只有 24 岁而已，现在哪个大公司会让一个 24 的小毛孩写这么大一个项目？ 我自己也有亲身的体会，在创业公司很重要的一点是不要把自己看成一个细分领域的工程师，比如 ios 工程师、Java 工程师或者前端工程师。你可能要解决各种不同层次的问题。虽然作为一个前端入职，我也曾经帮公司配置过 Amazon 云服务，包括 Amazon S3 的云存储、 Amazon Lambda Function 做的一些图片压缩以及一些权限设置。在一开始确实会觉得，WTF，我是来做前端的，这应该是一个后端的工作。但其实你老大不 care，他是要你来解决问题的. You are not a front-end engineer to me. More importantly you are an engineer that solved the problems.</em></p><p><strong>2. Today, the big technology companies are paying engineers a lot more money than Intel was when you left for Google. How should that fact affect an engineer’s decision to join a startup?</strong></p><p>Yeah, that’s hard. I think you have to view it as an investment. You’re essentially investing in yourself. You have to believe that at the startup, you’re going to learn and develop faster. If you don’t think it will provide that, maybe you shouldn’t take the job. If you go someplace with a lot of really smart people who are moving really fast, you can grow and develop as an engineer, or whatever you want to be, much faster than you would at a big company.</p><p>I would suggest thinking about joining a startup as more like going to grad school to learn. Optimize around learning when choosing a job. That’s the best thing. Then if a startup fails, you can always go back to Google and probably get paid a lot more, because now you’re actually a much better engineer than you would have been if you had stayed there like everyone else.</p><p><em>Paul 说在创业公司能学到更多东西，成长的更快。我并不赞同。一般而言创业公司没有大牛，无法给予你指导作用。他还建议，把加入一个创业公司看成是一个 grad school 来学习。我认为这恰好相反，大公司才能被当成是 grad school.</em></p><p><strong>3. Generally, when you are interviewing with a startup, how should you decide if it is the right company for you?</strong></p><p>Looking back, one of the things that really impressed me about Google, which is probably good advice for anyone choosing a startup to work at, was that the interviewers all asked really smart questions. <strong>They asked things that only people who really knew their stuff could have answered well</strong>. Urs asked me, “Let’s say you have a server, and it’s running really slowly for some reason, how do you diagnose the cause?” To answer that question, you actually have to understand systems really well.</p><p>Their questions required being able to think at all these different levels: “Is there something going on in the kernel? Do you understand that hard drives are not these magical things which spit out information? Do you know why random access takes time?”</p><p><strong>I only interviewed at one other company and they asked stupid questions like, “name the seven layers of the OSI Networking Stack,” or something that you’d pull out of a textbook, not things that were actually interesting.</strong> <em>(滑稽)</em></p><p>Also, when I first went to work at Google, I had the opposite feeling I described having at Intel. I was excited. I woke up in the morning and was excited to go to work. There was this buzz of productivity in the office all the time. <strong>I think that’s one way to know if a startup is doing well: When you go into their office, you can just tell. Are people busy working, or are they sitting around on Twitter wasting time?</strong> Are people showing up because they have to, or are they eagerly working because they’re excited? Google was a really energizing place to be back then.</p><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://triplebyte.com/blog/interview-with-gmail-creator-and-y-combinator-partner-paul-buchheit">Gmail Creator and YC Partner Paul Buchheit on Joining Google, How to Become a Great Engineer and Happiness</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;TripleByte 对 Gmail 创始人 Paul Buchheit 的进行了一个访谈，访谈内容很不错，我看完原文后获益匪浅，故在此做摘
      
    
    </summary>
    
    
      <category term="网络内容摘录" scheme="http://laijiawen.com/tags/%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9%E6%91%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>代理模式- JavaScript 设计模式(二)</title>
    <link href="http://laijiawen.com/posts/proxy-pattern-and-its-application/"/>
    <id>http://laijiawen.com/posts/proxy-pattern-and-its-application/</id>
    <published>2018-10-25T16:36:06.000Z</published>
    <updated>2018-10-26T18:25:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文通过多个例子介绍代理模式。代理模式有多种，我们主要介绍在 JavaScript 中常用的两种，虚拟代理和缓存代理。</p><h1 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h1><p>下文分别介绍通过虚拟代理实现以下两个例子：</p><ol><li>图片预加载</li><li>合并高频 HTTP 请求。</li></ol><h2 id="图片预加载"><a href="#图片预加载" class="headerlink" title="图片预加载"></a>图片预加载</h2><p>在 Web 开发中，图片预加载是一种常用的技术，如果直接给某个<code>&lt;img&gt;</code>标签标签节点设置<code>src</code>属性，由于图片过大或者网络不佳，图片的位置往往会显示一段时间的空白。常见的做法是用一张 loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到<code>&lt;img&gt;</code>节点里，这种场景就很适合用代理模式（虚拟代理），但我们还是先使用常规逻辑来书写这个代码，再使用代理模式重构。</p><p>我们想要实现这样一个效果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imgElement = <span class="built_in">document</span>.getElementsById(<span class="string">&quot;preloadImage&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> myImage = <span class="keyword">new</span> MyImage(imgElement);</span><br><span class="line"><span class="comment">// setSrc之后，在给定 url 返回之前，会加载一个 loading 的占位图。</span></span><br><span class="line">myImage.setSrc(<span class="string">`http://www.laijiawen.com/avatar/skateboard.jpg`</span>);</span><br></pre></td></tr></table></figure><p>调用<code>setSrc</code>的时候，会去请求给定 url 当中的图片，在请求到达之前，有一个 loading 的效果图片作为占位。</p><h3 id="常规逻辑"><a href="#常规逻辑" class="headerlink" title="常规逻辑"></a>常规逻辑</h3><p>上面的代码关键在于对 <code>MyImage</code>类的实现。在调用<code>setSrc</code>的时候，创建一个<code>Image</code>对象，用它来做真正的请求。而作为参数的<code>&lt;img&gt;</code>元素，则直接加载 loading 的 gif 图，当假的 <code>Image</code> 对象触发 <code>onload</code> 回调之后，再将真正的 <code>src</code> 赋值给 <code>&lt;img&gt;</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyImage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> LOADING_GIF_URL = <span class="string">`https://media.giphy.com/media/3oEjI6SIIHBdRxXI40/giphy.gif`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">imgElement</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.imgElement = imgElement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setSrc</span>(<span class="params">srcUrl</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.imgElement.src = srcUrl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.imgElement.src = MyImage.LOADING_GIF_URL;</span><br><span class="line">    image.src = srcUrl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类是可以正常工作的。可以点进这个 <a href="https://codepen.io/caren11/pen/PyXqMM?editors=1010">Codepen</a> 去看看，这个 codepen 同时加载了六张 4k 大图，应该能看到 loading 的效果，如果你的网速太快，没看到 loading，在 network 那里将网速调低一点再刷新一下。</p><p>虽然它可以工作，但这个类违反了<strong>单一职责原则</strong>。</p><blockquote><p>单一职责原则指的就是一个类（通常也包括对象和函数）而言，应该仅有一个引起它变化的原因。如果一个对象承担了多项职责，就意味着这个对象变的巨大。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合在了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。</p></blockquote><p>就上面这个类而言，它就承担了两个职责，包括给<code>img</code>节点设置<code>src</code>，以及预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职责的实现。</p><p>另外，在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反<a href="http://imweb.io/topic/5616652d5d6f37745e8f496f">开放-封闭原则</a>。如果我们只是从网络上获取一些体积很小的图片，或者五年后的网速快到根本不需要预加载，我们可能希望把预加载图片的这段代码从 <code>MyImage</code> 对象中删除。这时候就不得不改动 <code>MyImage</code> 类了。</p><p>实际上，我们需要的只是给<code>img</code>节点设置<code>src</code>，预加载图片只是一个锦上添花的功能。如果能把这个操作放在另一个对象里，自然是一个非常好的方法。</p><h3 id="使用代理模式实现"><a href="#使用代理模式实现" class="headerlink" title="使用代理模式实现"></a>使用代理模式实现</h3><p>我们要的效果是，让<code>MyImage</code>对象单纯地直接设置对应的<code>&lt;img&gt;</code>元素的<code>src</code>属性，而预加载 loading 图的职责则分给一个<code>ProxyImage</code>去做，这个<code>ProxyImage</code>就是我们的中介者。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p><code>MyImage</code>类这次很简单，直接设置<code>src</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyImage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">imgElement</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.imgElement = imgElement;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setSrc</span>(<span class="params">srcUrl</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.imgElement.src = srcUrl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. 预加载的功能在<code>ProxyImage</code>中实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">myImage</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.realImage = myImage;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setSrc</span>(<span class="params">srcUrl</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> fakeImage = <span class="keyword">new</span> Image();</span><br><span class="line">    fakeImage.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.realImage.setSrc(srcUrl);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fakeImage.src = srcUrl;</span><br><span class="line">    <span class="built_in">this</span>.realImage.setSrc(ProxyImage.LOADING_GIF_URL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static 的属性，我发现 chrome 还没支持 static ，故还是使用旧语法。</span></span><br><span class="line">ProxyImage.LOADING_GIF_URL = <span class="string">`https://media.giphy.com/media/3oEjI6SIIHBdRxXI40/giphy.gif`</span>;</span><br></pre></td></tr></table></figure><p>OK, 现在我们通过<code>ProxyImage</code>间接地访问 <code>MyImage</code>，<code>ProxyImage</code>控制了客户对<code>MyImage</code>的访问，并且在此过程中加入一些额外的操作（此例的额外操作是在图片请求完成前为真正的图片添加一个 loading 图）:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imgElement = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myImage&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> myImage = <span class="keyword">new</span> MyImage(imgElement);</span><br><span class="line"><span class="keyword">let</span> proxyImage = <span class="keyword">new</span> ProxyImage(myImage);</span><br><span class="line">proxyImage.setSrc(<span class="string">&quot;http://whatever.com&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p><a href="https://codepen.io/caren11/pen/bmOyRO?editors=1010">Codepen</a><br>代码的入口函数是<code>main()</code>，其为 DOM 中的五个图片加载了 5 张 4k 大图。</p><h2 id="合并高频-HTTP-请求"><a href="#合并高频-HTTP-请求" class="headerlink" title="合并高频 HTTP 请求"></a>合并高频 HTTP 请求</h2><p>假设我们有这样一个需求, 页面上有多个文件，都可以勾选，勾选之后立即触发上传。当我们选中 3 个 checkbox 的时候，依次往服务器发送了 3 次上传文件的请求。假设我单身二十年手速惊人，一次点了十几个文件，可以想象，这种频繁的网络请求将会给服务器带来很大的压力。解决方案是，我们可以通过一个代理函数 proxyUploadFile 来收集一段时间内的请求，然后一次性发给服务器。比如等待两秒后，再将需要同步的文件一次性发给服务器。如果不是对实时性要求非常高的系统，2 秒的延迟不会带来太大的副作用，却能大大减轻服务器的压力。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uploadFile = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Begin to upload file, the id is: <span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxyUploadFile = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer,</span><br><span class="line">    cache = [], <span class="comment">// 保存一定时间内需要上传的文件id</span></span><br><span class="line">    timeout = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    cache.push(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="comment">// 保证不会覆盖已经启动的定时器。</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      uploadFile(cache.join(<span class="string">&quot;,&quot;</span>)); <span class="comment">// 2s后发送需要上传的文件集合。</span></span><br><span class="line">      cache = [];</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> checkboxs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; checkboxs.length; i++) &#123;</span><br><span class="line">    checkboxs[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.checked) &#123;</span><br><span class="line">        proxyUploadFile(<span class="built_in">this</span>.id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><p>该例子较为简单，不赘述，读者可以去这个 <a href="https://codepen.io/caren11/pen/EdGqKr?editors=1111">Codepen</a> 玩一玩。</p><h1 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h1><p>缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前的一致，则可以直接返回前面存储的计算结果。</p><p>本节通过一个计算乘积的例子介绍缓存代理。</p><h2 id="常规思路的实现"><a href="#常规思路的实现" class="headerlink" title="常规思路的实现"></a>常规思路的实现</h2><p>先实现一个计算乘积的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> product = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    product *= <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> product;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们要想办法缓存结果，很自然的想到了可以通过闭包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cachedMult = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 比如参数是 20 20，我们以 &quot;20,20&quot; 的形式作为 cache 的 key，</span></span><br><span class="line">    <span class="comment">// 此处不考虑参数的值相同而顺序不同的情况。</span></span><br><span class="line">    <span class="keyword">let</span> args = [].join.call(<span class="built_in">arguments</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cache[args]) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache[args];</span><br><span class="line">    &#125;</span><br><span class="line">    cache[args] = mult.apply(<span class="built_in">this</span>, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">return</span> cache[args];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>调用的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cachedMult(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>); <span class="comment">// 8000</span></span><br></pre></td></tr></table></figure><h2 id="使用代理的实现"><a href="#使用代理的实现" class="headerlink" title="使用代理的实现"></a>使用代理的实现</h2><p>Hold on hold on.</p><p>仔细观察一下常规思路的实现。你会发现实际上常规思路的实现就是所谓的缓存代理！我们将 <code>cachedMult</code> 这个函数的名字修改成 <code>proxyMult</code>，是不是一切都很熟悉？我们调用<code>proxyMult</code>，这个函数缓存了计算结果，实际调用的函数是<code>mult</code>。<br>Yep, 它就是我们熟悉的代理模式。所以缓存代理，<strong>在 Javascript 中实际上就是用闭包做缓存。</strong></p><p>一般套路是这样的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxyWhatever = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ..</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>用一个立即执行函数返回一个函数，由于这个函数引用了其作用域以外的<code>cache</code>数组，它成了一个闭包。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理模式包括许多小分类，我们在本文中介绍了 JavaScript 中最常用的虚拟代理和缓存代理。虽然代理模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便直接访问某个对象的时候，再编写代理也不迟。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文通过多个例子介绍代理模式。代理模式有多种，我们主要介绍在 JavaScript 中常用的两种，虚拟代理和缓存代理。&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
      <category term="JavaScript 设计模式" scheme="http://laijiawen.com/categories/JavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="读书笔记" scheme="http://laijiawen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript设计模式" scheme="http://laijiawen.com/tags/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式- JavaScript 设计模式(一)</title>
    <link href="http://laijiawen.com/posts/strategy-pattern-and-its-application/"/>
    <id>http://laijiawen.com/posts/strategy-pattern-and-its-application/</id>
    <published>2018-10-25T09:56:08.000Z</published>
    <updated>2020-11-10T02:01:37.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在“设计模式系列“第一篇的开头"><a href="#写在“设计模式系列“第一篇的开头" class="headerlink" title="写在“设计模式系列“第一篇的开头"></a>写在“设计模式系列“第一篇的开头</h1><p>本系列作为《JavaScript 设计模式与开发实践》一书的读书笔记，将介绍前端开发中常用的一些设计模式。目前已经有非常多的优秀文章将设计模式讲的很好了，笔者写作的初衷有以下几点：</p><ol><li>备忘。</li><li><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/">教是最好的学</a>。只有当我们能将知识准确、完整的用自己的语言阐述出来，才能说明我真的懂了。</li></ol><p>总体而言，是为了巩固知识。<br>本系列所有文章的讲述逻辑一般将会是这样的：</p><ol><li>先讲述从一个具体的需求。</li><li>讲述正常思维的实现以及其缺点，缺点一般是代码难以维护。</li><li>讲述如何使用某个设计模式实现该需求及其优点。</li><li>该设计模式的拓展。</li></ol><p>之所以使用这样的介绍逻辑，是因为我们就是这样思考的。当我们遇到一个业务需求，心里面并不是想着：</p><blockquote><p>好的，这次我要用命令模式实现它！</p></blockquote><p>而是在遇到一个问题的时候，突然感觉这个需求好像和某个设计模式的适用场景情境很像，于是心想</p><blockquote><p>咦，这个场景好像和命令模式的场景很相似，我去看看能不能用命令模式实现它。</p></blockquote><p>所以，<strong>我们的介绍重点不在于设计模式，而在于场景</strong>。读者需要理解的重点也是为何这个场景需要使用某个模式，优点体现在哪里，而不是这个设计模式的定义是什么。</p><p>话不多说，让我们开始介绍策略模式。按照惯例，应该先介绍单例模式，但单例模式太简单了，笔者不愿赘述，故直接从策略模式开始。</p><h1 id="例子1：计算年终奖"><a href="#例子1：计算年终奖" class="headerlink" title="例子1：计算年终奖"></a>例子1：计算年终奖</h1><p>现在假设一个公司的年终奖是根据<strong>工资基数</strong>和<strong>绩效等级</strong>来发放的：</p><table><thead><tr><th>绩效等级</th><th>年终奖数额</th></tr></thead><tbody><tr><td>S</td><td>四倍工资</td></tr><tr><td>A</td><td>三倍工资</td></tr><tr><td>B</td><td>两倍工资</td></tr></tbody></table><h2 id="初级工程师版本"><a href="#初级工程师版本" class="headerlink" title="初级工程师版本"></a>初级工程师版本</h2><p>一个新手的JavaScript工程师会这样写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params">performanceLevel, salary</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (performanceLevel === <span class="string">&quot;S&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (performanceLevel === <span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (performanceLevel === <span class="string">&quot;B&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这带来的问题是假设你要新增一个<code>C</code>绩效等级，就要去增加一个<code>if</code>，新增这个<code>if</code>的同时又有可能改动到别的逻辑。一个重要的原则是，凡是你发现你代码里面很多<code>if</code>判断，说明它可以被优化。具体的优化方式有很多种，可以点击这个<a href="https://jrsinclair.com/articles/2017/javascript-but-less-iffy/">链接</a>去了解一下。</p><h2 id="中级工程师版本-策略模式"><a href="#中级工程师版本-策略模式" class="headerlink" title="中级工程师版本(策略模式)"></a>中级工程师版本(策略模式)</h2><p>一个略有经验的工程师则会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Strategies = &#123;</span><br><span class="line">  <span class="string">&quot;S&quot;</span>: <span class="function"><span class="params">salary</span>=&gt;</span> salary * <span class="number">4</span>,</span><br><span class="line">  <span class="string">&quot;A&quot;</span>: <span class="function"><span class="params">salary</span>=&gt;</span> salary * <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;B&quot;</span>: <span class="function"><span class="params">salary</span>=&gt;</span> salary * <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculateBonus = <span class="function">(<span class="params">performanceLevel, salary</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Strategies[performanceLevel](salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个绩效等级为S，薪资为15000的员工。</span></span><br><span class="line">calculateBonus(<span class="string">&#x27;S&#x27;</span>, <span class="number">15000</span>); <span class="comment">// 60000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上, 这就是策略模式。<br><img src="https://user-gold-cdn.xitu.io/2018/10/25/166a91c67a20940a?w=250&h=250&f=png&s=31371" alt=""></p><p>在传统面向对象语言中，要实现策略模式需要定义</p><ol><li>一组策略类，策略类封装了具体的算法。</li><li>环境类 Context，Context 接受客户的请求，随后将请求委托给某一个策略类。</li></ol><p>太麻烦了。而 JavaScript 则由于它丰富的表达能力，可以将<code>calculateBonus</code>函数看成是Context，将<code>Strategies</code>对象看成一组策略，轻松地实现了一个策略模式。</p><h2 id="额外的tips"><a href="#额外的tips" class="headerlink" title="额外的tips"></a>额外的tips</h2><p>上文“中级工程师”版本的写法其实还有个小问题，就是 performanceLevel 这个变量是硬编码的，比如<code>&quot;S&quot;</code>, <code>&quot;A&quot;</code>, <code>&quot;B&quot;</code>。这么短的一个字符可能不会带来什么问题，但假设这个策略的名称比较长，比如<code>&quot;Christina&quot;</code>，那你就很容易敲错，敲错就出 bug 了嘛。</p><p>我们可以用ES6的<a href="http://es6.ruanyifeng.com/#docs/symbol">Symbol</a>和<a href="http://es6.ruanyifeng.com/#docs/destructuring">解构</a>把它改写一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PERFORMANCE_LEVEL = &#123;<span class="attr">S</span>:<span class="string">&#x27;S&#x27;</span>, <span class="attr">A</span>: <span class="string">&#x27;A&#x27;</span>, <span class="attr">B</span>: <span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;S, A, B&#125;  = PERFORMANCE_LEVEL;</span><br><span class="line"><span class="keyword">const</span> Strategies = &#123;</span><br><span class="line">  [S]: <span class="function"><span class="params">salary</span>=&gt;</span> salary * <span class="number">4</span>,</span><br><span class="line">  [A]: <span class="function"><span class="params">salary</span>=&gt;</span> salary * <span class="number">3</span>,</span><br><span class="line">  [B]: <span class="function"><span class="params">salary</span>=&gt;</span> salary * <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> calculateBonus = <span class="function">(<span class="params">performanceLevel, salary</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Strategies[performanceLevel](salary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calculateBonus(S, <span class="number">15000</span>); <span class="comment">// 60000</span></span><br></pre></td></tr></table></figure><p>这样会更好一点点，但当然，这和设计模式关系不大。<br>这个例子较为简单，接下来我们讲述一个更为常见的表单校验的例子。</p><h1 id="例子2：表单校验"><a href="#例子2：表单校验" class="headerlink" title="例子2：表单校验"></a>例子2：表单校验</h1><p>表单几乎是前端工程师写的最多的东西，登录注册、修改用户信息都离不开表单。在提交一个表单给后台之前，客户端一般要对一些数据进行校验，比如 Email、电话是否符合格式，某些必填字段是否为空等等。</p><p>现在假设我们在编写一个注册页面，校验规则如下：</p><ul><li>用户名不能为空</li><li>密码长度不能少于6位</li><li>手机号码必须符合格式。</li></ul><h2 id="常规思维写法"><a href="#常规思维写法" class="headerlink" title="常规思维写法"></a>常规思维写法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;registerForm&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  请输入用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  请输入密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  请输入手机号码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;phone&quot;</span> <span class="attr">name</span>=<span class="string">&quot;phoneNumber&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> registerForm = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;registerForm&#x27;</span>);</span><br><span class="line"></span><br><span class="line">registerForm.onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;userName, password, phoneNumber&#125; = registerForm;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">userName.value === <span class="string">&#x27;&#x27;</span> </span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;用户名不能为空&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">password.value.length &lt; <span class="number">6</span></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;密码长度不能少于6位&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(phoneNumber.value))&#123;</span><br><span class="line">    alert(<span class="string">&#x27;手机号码格式不正确&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入这个<a href="https://codepen.io/caren11/pen/mzQaWm">Codepen</a>玩一下。</p><p>可以看到，在<code>onsubmit</code>函数中，我们对<code>registerForm</code>的每个字段逐一验证，这是十分符合逻辑的写法。但是略有经验的工程师会知道，将来我们可能要新增一些字段，比如邮箱；还有可能要对某些字段新增校验规则，比如要求密码必须同时包含大小写字符和数字。这样一来，我们就要经常对<code>onsubmit</code>函数进行修改。</p><h2 id="策略模式写法"><a href="#策略模式写法" class="headerlink" title="策略模式写法"></a>策略模式写法</h2><p>原书的作者曾探大佬重构这段代码的时候，上来就封装了一个策略对象，笔者认为这样不太好理解。我们来先从目的出发，反推我们应该如何使用策略模式进行重构。一些阅读代码能力很强的读者可以直接跳到尾部的完整代码直接进行查看。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>读者可以思考一分钟，你会如何重构这部分代码。</p><p>笔者的思路是这样的。基于我们写表单的经验，我们知道在将来我们可能会</p><ol><li>新增某些字段。</li><li>对某个字段进行多种不同的校验，输出不同的提示信息。</li><li>校验别的表单，但我不希望重写一份校验规则。</li></ol><p>基于以上假设，我们想要的效果是这样的：</p><p>a. 在表单提交的时候，只需要调用 <code>validate()</code> 函数即可进行校验:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">registerForm.onsubmit = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> errorMessage = validate();</span><br><span class="line">  <span class="keyword">if</span> (errprMessage) &#123;</span><br><span class="line">    alert(errorMessage);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>b. <code>validate()</code>函数负责创建一个<code>Validator</code>，添加相应的规则，并执行校验：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> validator = <span class="keyword">new</span> Validator();</span><br><span class="line">  <span class="comment">// 一次添加单个规则, (longerThan6 和 isPhone 都是函数)</span></span><br><span class="line">  validator.add(registerForm.password, longerThan6, <span class="string">&quot;密码长度必须大于6位&quot;</span>);</span><br><span class="line">  validator.add(registerForm.phoneNumber, isPhone, <span class="string">&quot;电话号码格式错误&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次添加多个规则</span></span><br><span class="line">  validator.add(registerForm.userName, [</span><br><span class="line">    &#123;</span><br><span class="line">      rule: <span class="function"><span class="params">val</span> =&gt;</span> val.length &gt; <span class="number">6</span>,</span><br><span class="line">      message: <span class="string">&quot;用户名长度必须大于六位&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; <span class="attr">rule</span>: notEmpty, <span class="attr">message</span>: <span class="string">&quot;用户名不能为空&quot;</span> &#125;</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始校验，成功则返回false，失败则返回对应的errorMessage。</span></span><br><span class="line">  <span class="keyword">return</span> validator.start();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目标就是这样，那么关键就是<code>Validator</code>这个类的实现了。</p><h3 id="Validator类的实现"><a href="#Validator类的实现" class="headerlink" title="Validator类的实现"></a>Validator类的实现</h3><p>我们刚才看到，<code>Validator</code>类主要包含两个方法，<code>add</code>和<code>start</code>，除此之外，我们还需要一个<code>rules</code>数组，用于缓存待验证的值、验证函数、以及 error message. 具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rules = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 该方法负责添加验证规则，存储在 this.rules 中。</span></span><br><span class="line"><span class="comment">   * 其接受三个参数，第一个参数是input元素( Element )</span></span><br><span class="line"><span class="comment">   * 第二个参数可能是数组或函数，若第二个参数是数组，忽略第三个参数，</span></span><br><span class="line"><span class="comment">   * 且该数组的元素结构必须是 &#123; validateFunc: Function, errorMessage: String &#125;。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Element&#125;</span> <span class="variable">inputElement</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Array | Function&#125;</span> <span class="variable">rules</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> <span class="variable">message</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@memberof <span class="variable">Validator</span></span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">inputElement, rules, errorMessage</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> val = inputElement.value; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第二个参数是函数，那就是用于验证的函数咯。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> rules === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> validateFunc = rules; <span class="comment">// 没啥意义的赋值，为了你更好的理解。</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.rules.push(&#123;</span><br><span class="line">        value: val,</span><br><span class="line">        validateFunc: validateFunc,</span><br><span class="line">        errorMessage: errorMessage</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第二个参数是数组，那就是一组规则，忽略第三个参数。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(rules)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> rule <span class="keyword">of</span> rules) &#123;</span><br><span class="line">        <span class="built_in">this</span>.rules.push(&#123;</span><br><span class="line">          value: val,</span><br><span class="line">          validateFunc: rule.validateFunc,</span><br><span class="line">          errorMessage: rule.errorMessage</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> rule <span class="keyword">of</span> <span class="built_in">this</span>.rules) &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; value, validateFunc, errorMessage &#125; = rule;</span><br><span class="line">      <span class="keyword">if</span> (!validateFunc(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> errorMessage;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证通过。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最后还需要一个规则对象-策略对象"><a href="#最后还需要一个规则对象-策略对象" class="headerlink" title="最后还需要一个规则对象(策略对象)"></a>最后还需要一个规则对象(策略对象)</h3><p>细心的读者会发现，在<code>validate</code>函数中用了三个变量,<code>longerThan6</code>, <code>isPhone</code>和<code>notEmpty</code>。他们其实都是函数，用于被调用来验证值的正确性嘛。</p><p>为了可复用，我们要将一些常见的验证规则保存起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rules = &#123;</span><br><span class="line">  longerThan6: <span class="function"><span class="params">val</span> =&gt;</span> val &amp;&amp; val.length &gt;= <span class="number">6</span>,</span><br><span class="line">  isPhone: <span class="function"><span class="params">val</span> =&gt;</span> val &amp;&amp; <span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(val),</span><br><span class="line">  notEmpty: <span class="function"><span class="params">val</span> =&gt;</span> val &amp;&amp; val.length != <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要使用的时候:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;longerThan6, isPhone, notEmpty&#125; = Rules;</span><br></pre></td></tr></table></figure><p>解构语法真是好用啊我的老天鹅。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://codepen.io/caren11/pen/rqQbZB?editors=1111">Codepen</a></p><h1 id="解析策略模式"><a href="#解析策略模式" class="headerlink" title="解析策略模式"></a>解析策略模式</h1><p>策略模式的定义是：<strong>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</strong></p><p>前文提及，在传统面向对象语言中，一个基于策略模式的程序至少由两部分组成:</p><ol><li><strong>一组策略类</strong>: 策略类封装了具体的算法，并负责具体的计算过程。</li><li><strong>一个环境类</strong> Context: Context 接受用户的请求，随后把请求委托给一个策略类。</li></ol><p>而在美丽的 JavaScript 中，一组策略类完全可以使用一个<strong>策略对象</strong>代替。这个策略对象的 key 是各个策略名称， value 是对应策略的具体算法。</p><p>如第一个计算工资例子中的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Strategies = &#123;</span><br><span class="line">  <span class="string">&quot;S&quot;</span>: <span class="function"><span class="params">salary</span>=&gt;</span> salary * <span class="number">4</span>,</span><br><span class="line">  <span class="string">&quot;A&quot;</span>: <span class="function"><span class="params">salary</span>=&gt;</span> salary * <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;B&quot;</span>: <span class="function"><span class="params">salary</span>=&gt;</span> salary * <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及第二个表单校验例子中的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rules = &#123;****</span><br><span class="line">  longerThan6: <span class="function"><span class="params">val</span> =&gt;</span> val &amp;&amp; val.length &gt;= <span class="number">6</span>,</span><br><span class="line">  isPhone: <span class="function"><span class="params">val</span> =&gt;</span> val &amp;&amp; <span class="regexp">/(^1[3|5|8][0-9]&#123;9&#125;$)/</span>.test(val),</span><br><span class="line">  notEmpty: <span class="function"><span class="params">val</span> =&gt;</span> val &amp;&amp; val.length != <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么<strong>环境类</strong>呢？其实在 JavaScript 中，随便写一个函数就可以了。</p><p>简而言之，我靠..写到最后发现 JavaScript 中根本没有策略模式。基本上只要你熟悉了通过一个对象的方式来避免某些情况下的多个<code>if</code>，你就算是掌握了策略模式了。既然如此，我就不赘述策略模式的优点了，大体是避免了多个<code>if</code>、方便策略函数的重用等等。</p><p>顺便看了一下原书，原来作者在末尾也说了这一点:</p><blockquote><p>在函数作为一等对象的语言中，策略模式是隐形的。strategy就是值作为函数的变量。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在“设计模式系列“第一篇的开头&quot;&gt;&lt;a href=&quot;#写在“设计模式系列“第一篇的开头&quot; class=&quot;headerlink&quot; title=&quot;写在“设计模式系列“第一篇的开头&quot;&gt;&lt;/a&gt;写在“设计模式系列“第一篇的开头&lt;/h1&gt;&lt;p&gt;本系列作为《JavaScri
      
    
    </summary>
    
      <category term="JavaScript 设计模式" scheme="http://laijiawen.com/categories/JavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="读书笔记" scheme="http://laijiawen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JavaScript设计模式" scheme="http://laijiawen.com/tags/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 中 table 布局的的重叠边框 bug</title>
    <link href="http://laijiawen.com/posts/a-collapsing-border-bug-in-chrome/"/>
    <id>http://laijiawen.com/posts/a-collapsing-border-bug-in-chrome/</id>
    <published>2018-10-22T17:53:30.000Z</published>
    <updated>2018-10-22T17:53:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在实现一个表格布局的时候遭遇了 Chrome 的一个 bug。没错，这次不是我们的问题，是 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=356132">chrome 的问题</a>。<br>后文简要介绍这个 bug。</p><a id="more"></a><h2 id="现象和出现条件"><a href="#现象和出现条件" class="headerlink" title="现象和出现条件"></a>现象和出现条件</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p><code>table</code>布局中，<code>&lt;td&gt;</code> 的 border 在一定条件下会有诡异的现象，如这个 <a href="https://codepen.io/caren11/pen/dgjeoZ">codepen</a> 所示，截图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/166a100e385cb53e?w=712&h=335&f=png&s=24472" alt=""></p><p>option 2 绿色的 <code>border-bottom</code> “延伸”到了 option3 下面去了。同样的，option 6 和 option 7 被选中时也会有类似的 Bug.</p><h3 id="出现条件"><a href="#出现条件" class="headerlink" title="出现条件"></a>出现条件</h3><p>这个 bug 的出现须满足以下两个条件：</p><ol><li><code>table</code>元素的 CSS 写了 <code>border-collapse: collapse</code>， 这个属性表示表格的单元格(<code>&lt;td&gt;</code> 和<code>&lt;th&gt;</code>)的 border 会 collapse （重叠），即拥有和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">margin collapse</a> 一样的现象: 两条相邻的 border 会合并成一条。</li><li>使用了<code>colspan</code>属性。</li></ol><p>举个<strong>例子</strong>：上图 Option5 这个<code>&lt;td&gt;</code>就使用了<code>colspan=&quot;2&quot;</code>，代表这个<code>&lt;td&gt;</code>占据两列。这时候，Option5 的上下 border 都有几率发生奇怪的现象。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们不知道他出现的根本原理，因为 chrome 开发人员也不知道。</p><blockquote><p>It’s a known (old) issue in our table code. Collapsing borders are determined based on adjacent cells and our code doesn’t deal correctly with spanning cells (we only consider the cell adjoining the first row / column in a row / column span). On top of that, our border granularity is determined by the cell’s span.<br>To fix this bug, we would need to overhaul our collapsing border code, which is a big undertaking.</p></blockquote><p>翻译:</p><blockquote><p>这个 bug 我们早就知道了，但是太麻烦了我们不想改。</p></blockquote><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>去掉两个条件之一呗，但显然，第二个条件是不能被去掉的，因为在一些情况下，我们就是需要某个单元格占据两列的宽度。</p><p>因而我们只能去掉第一个条件，与此同时，我们需要在<code>&lt;table&gt;</code> 处加一个<code>cellspacing=&quot;0&quot;</code>的属性，以达到和<code>border-collapse: collapse</code>类似的效果。</p><h2 id="如何解决-更新"><a href="#如何解决-更新" class="headerlink" title="如何解决(更新)"></a>如何解决(更新)</h2><p>上面的解决方案使用了<code>cellspacing=&quot;0&quot;</code>这个属性，但出于好奇我搜了一下<code>cellspacing</code>，想知道它的默认值，而后发现这个属性已经不被推荐使用了:<br><img src="https://user-gold-cdn.xitu.io/2018/10/24/166a572b342de7a5?w=763&h=280&f=png&s=59897" alt=""><br>应该在 CSS 中使用 <code>border-spacing: 0</code></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我刚看到这个现象的时候，在一瞬间直觉就告诉我这是 Chrome 的 bug 了。这个直觉从何而来呢？ 从张鑫旭大佬的书《CSS 世界》中得来的。说来惭愧，买回来这本书数月，还没开始看，但由于它在桌子上就随便翻了一下，看到了一个标题，了解 CSS 世界中的“未定义行为”。我并没有细看，只是扫了一眼，简而言之就是浏览器存在着许多未定义行为，毕竟 CSS 的各种组合太丰富了，程序员也不可能完全考虑到所有的情况。故未定义的行为可能会有各种奇怪的现象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在实现一个表格布局的时候遭遇了 Chrome 的一个 bug。没错，这次不是我们的问题，是 &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=356132&quot;&gt;chrome 的问题&lt;/a&gt;。&lt;br&gt;后文简要介绍这个 bug。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Bug" scheme="http://laijiawen.com/tags/Bug/"/>
    
      <category term="CSS" scheme="http://laijiawen.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>如何突破环境对人的制约</title>
    <link href="http://laijiawen.com/posts/how-to-break-though-the-constraints-of-environment/"/>
    <id>http://laijiawen.com/posts/how-to-break-though-the-constraints-of-environment/</id>
    <published>2018-09-27T14:22:23.000Z</published>
    <updated>2020-11-10T02:01:37.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者本科毕业后进入一家初创公司。大家都知道，对于搞技术的同学来说，刚毕业就进入初创公司（相较于大公司）有着显而易见的弊端，其一是初创公司没有技术大牛，无法给予技术上的指导；其二是初创公司在开发流程、开发规范方面都远远不及大公司。作为一个努力上进的人(手动狗头:D )，在这个背景下，笔者就经常思考，如何才能突破环境对我的制约，从而获得与那些毕业后进入腾讯等大公司的同学取得相同甚至更多的成长，故有此文。</p><p>本文先陈述环境制约人发展的三个原因，接着针对这些原因提出解决方案。</p><h2 id="环境对人的制约的三个原因"><a href="#环境对人的制约的三个原因" class="headerlink" title="环境对人的制约的三个原因"></a>环境对人的制约的三个原因</h2><p>本文既然是探讨如何突破环境对人的制约，就必然要先说环境如何制约人的发展。首先明确一点，本文所提及的 “环境”，均指日常接触的人，而非自然环境。 “更好的环境” 指能力、思想水平更高的人。本文提及的 “建议” 非仅指言语建议，其还包括技术指导以及模范作用等。</p><p>环境影响人的发展大体有以下三个原因，下文分别陈述这三点：</p><ol><li>更好的环境能提供更好的建议。</li><li>鲜活性效应(vividness effect)</li><li>对于网络信息的信任度的下降</li></ol><h3 id="更好的环境能提供更好的建议"><a href="#更好的环境能提供更好的建议" class="headerlink" title="更好的环境能提供更好的建议"></a>更好的环境能提供更好的建议</h3><p>更好的环境能提供更好的建议，这些建议会一定程度上影响我们的选择，而我们的选择铸就了我们。这一点实际上是无须论证的，但我还是讲一个很简单的例子。</p><p>你刚上 xx 大学的 CS 专业，你发现居然要学高等数学、线性代数这些似乎对编程没啥帮助的科目，于是你问师兄:</p><blockquote><p>师兄师兄，高数好难啊 555555，有必要学好高数吗 T_T ？”</p></blockquote><p>假设你处在一个三本院校，他们有更大的可能性会说：</p><blockquote><p>高数根本没啥用，编程会高中数学就够了。</p></blockquote><p>但如若你处在一个 985/211 院校，他们的回答更可能是：</p><blockquote><p>好好学，以后无论搞哪方面的研究，高数都是基础。</p></blockquote><p>而事实不言而喻，如果想在编程道路上走的更远，高数是不可或缺的，这一点我就不论证了。</p><p>就大学而言，选哪门课、加入哪个社团、大四选择考研还是直接就业还是出国都是选择，而你自身的视野以及环境给予的建议则会影响你的选择（事实上你自身的视野大部分也来自于你之前的环境，包括家庭环境等）。当身边的室友都在纠结要读研还是工作的时候，我就已经做好了直接就业的选择。</p><p>现在回想起来，是我自身的视野和格局受限了。我还认识一个朋友，让我们叫她克里斯蒂娜，她的目标则是进入 AI Lab 或者当一个大学教授（虽然她尚未付出与这个目标匹配的努力），这是我从来没有想过的。她之所以会有这样的目标，从根本上而言是因为家庭环境（由此带来了各方面环境的优越），从言谈中能感知到，她的家庭应该是相对富裕的，她的父亲也是搞技术的，她的阿姨也是某个省的理科状元。</p><p>这本是一个很容易理解的论点，但还是讲了挺多，就此打住。</p><h3 id="鲜活性效应-vividness-effect"><a href="#鲜活性效应-vividness-effect" class="headerlink" title="鲜活性效应(vividness effect)"></a>鲜活性效应(vividness effect)</h3><p>环境制约人发展的第二个原因是鲜活性效应。由于鲜活性的影响，相较于其他可能更有价值的信息来源，我们更容易接受身边人的建议。事实上，这一点与前文“更好的环境能提供更好的建议”紧密相连。</p><p><strong>鲜活性效应</strong>是一个认知心理学的概念，它是指当面临解决问题和或做决策的情境时，人们会从记忆中提取与当前的情境有关的信息。因此，对于解决当前的问题而言，越是容易获取的的事情，越会被人们用来解决问题或者决策。而信息或事情的鲜活性就是强烈影响信息的可获得性的一个因素。</p><p>这样就出现了问题，因为没有什么会比一个人真真实实的叙述他们自身的经历更加具有鲜活性了，这使得其他更可靠来源的信息变得黯然失色。</p><p>举一个简单的例子，你现在想要买一台 Android 手机，正在小米、华为和一加三个选项中徘徊不定，在看了一系列评测文章和统计数据之后，你终于决定要买小米了——直到，某天你跟你一个朋友说起买手机的事情，他告诉你小米手机巨多广告，贼垃圾。理论上来说，单单一个事例不应该那么严重的影响你的决策，毕竟你看了那么多的评测文章，逛了那么久贴吧，看了那么多统计数据。</p><p>但你想想，在这个情况下你会不会瞬间觉得不该买小米？换作是我也会的。评测给出的结果和统计数据有价值还是你朋友的切身使用体验有价值呢？这里有同学就会说了：“当然是朋友的切身使用体验啦！”</p><p><img src="http://wx3.sinaimg.cn/large/814268e3gy1flebk60hblj209q069dfw.jpg" alt="无语"></p><p>在这里我不想普及概率论基本常识，这样回答的同学可以悄悄 <code>Ctrl + W</code> 关闭这个网页，继续刷微博了。答案是统计数据更有价值。从中推而广之，我们的环境给出的建议，都不一定是很好的建议，理论上而言，知乎高赞回答和经典书籍上的建议更具有参照性。高赞回答因为有如此多的人认同，证明了它一定程度上的正确性和可行性。经典书籍之所以成为经典书籍，也正是它因为对许多人都有所启发。</p><p>可是我们看过知乎上的高赞回答后，看的时候可能醍醐灌顶，往往过几天就忘了，行事依旧按照原本的习惯，做决策时也未必能够充分考虑你从高赞回答中了解到的东西。但是身边人给的建议则完全不同，由于鲜活性效应的影响，它会成为几乎 TOP1 的影响因子。</p><h3 id="对于网络信息的信任度下降"><a href="#对于网络信息的信任度下降" class="headerlink" title="对于网络信息的信任度下降"></a>对于网络信息的信任度下降</h3><p>上面提到，我们对知乎等网站上的高赞回答中提出的建议的接受程度往往没有对身边人的建议的接受程度高，这里除了鲜活性效应的影响，另一个重要的原因我认为是我们对于从网络中获取的信息的信任度正逐渐下降。而信任度下降的原因之一当然是其本身的可靠性在下降。</p><p>无论是“说出你刚编的故事”的知乎，还是医疗广告搞竞价排名的百度，或是各种起了博人眼球标题以获取阅读量的各种公众号文章，都一定程度上影响了我们对网络信息的信任度。</p><p>另一个我们对网络信息的信任度下降的原因在于，我们在实践网络上给出的建议时，时长遭遇挫折，要么无法形成习惯，要么尝试了却没有效果。比如我就不止一次的看到别人说冥想的奇效，可以提高专注力、使心情平静等等。但当我自己尝试的时候，却一点也感觉不到。</p><h2 id="如何突破环境对人的制约"><a href="#如何突破环境对人的制约" class="headerlink" title="如何突破环境对人的制约"></a>如何突破环境对人的制约</h2><p>前文论述了环境制约人的原因，总结而言就是一句话，由于<strong>鲜活性效应</strong>以及网络信息的噪音太多，我们倾向于接受身边人的建议，而较差的环境能够给予的建议通常来说也是较差的，接受了这些建议以后我们将会作出概率意义上更差的决策，从而使得我们的人生概率意义上过得更差。</p><p>针对以上原因，本文提出几点方法，尝试帮助我们突破环境对我们个人发展的制约：</p><ol><li>多阅读，持续学习</li><li>消除信息噪音，主动获取信息。</li><li>走出 comfort zone, 自己解决问题</li><li>勤于思考</li></ol><h3 id="多阅读，持续学习"><a href="#多阅读，持续学习" class="headerlink" title="多阅读，持续学习"></a>多阅读，持续学习</h3><p>在周围环境能给予你的提升有限的情况下，经典书籍无疑将成为最重要的信息来源。你要多看书。你将会知道自己思维的局限，你会渐渐以一种全然不同的视角看待世界，你会以一种更科学合理的方式来决策。You know, 人与人的差别往往是视野和格局的差别，而视野和格局养成除了环境的熏陶，就只能靠书了。</p><p>仅就上文提及的鲜活性效应而言，假设你看过《How To Think Straight About Psychology》（译作《如何正视心理学》），你就会知道对于科学研究而言，<strong>见证叙述</strong>是没有价值的。了解这一点，将会减少鲜活性效应对你的影响。这个道理也可以推广到生活中，假设你患了一种疾病，有朋友告知你他也曾患过同样的病，并且通过一种中医的偏方治愈了，你其实是要存疑的，因为这可能存在安慰剂效应，也有可能是其他的因素使得他痊愈了，这也是基本的 critical thinking, 不赘述。</p><p>这里插一句，读者可能注意到，本文自始至终都强调的是概率意义上的更好或更差，并非绝对意义上的更好或更差。很好理解，我们在一个较差的环境也可能会遇到一个给予我们技术上或者人生上的指导的大神，只是相对于在更好的环境中概率更低一点罢了。笔者以前阅读过《万万没想到——用理工科思维理解世界》一书，里面也强调概率论对于我们理解世界的重要性，我深以为然，故行文过程中总会避免绝对化的描述。</p><h3 id="消除信息噪音，主动获取信息"><a href="#消除信息噪音，主动获取信息" class="headerlink" title="消除信息噪音，主动获取信息"></a>消除信息噪音，主动获取信息</h3><p>在这个娱乐至死的时代，信息噪音太多了，你关注了几十个微信公众号，刷着微博、知乎、抖音、朋友圈、推特、油管、program-think(手动滑稽)。有价值的信息有多少？其中你真的吸收了的信息又有多少？</p><p>这个问题问的我自己都直击心灵。没多少，说实话。</p><p>一个高赞的知乎回答，我看过后醍醐灌顶。过了两个月后，无意中再次看到，竟如若初见般醍醐灌顶。这说明第一次的醍醐灌顶之后我根本没记得多少，我相信这不是我一个人的体验。在这样的背景之下，如何高效的、主动的获取信息则成了每个想要努力向上的人的必修课。有的同学又要说了：</p><blockquote><p>我去刷微博、知乎、抖音，不是在主动获取信息吗？</p></blockquote><p>这其实是被动获取，你刷的东西都是平台推荐给你的，自己主动关注的并不多。</p><p>那么我们要如何主动获取信息？我的建议是先把手机上的微博、知乎、抖音都卸了。它们的内容确实很有趣，但其实使用时间的增多，你能从中获取的快乐是<a href="https://wiki.mbalib.com/wiki/%E8%BE%B9%E9%99%85%E6%95%88%E7%94%A8%E9%80%92%E5%87%8F%E6%B3%95%E5%88%99">边际递减</a>的，这一点其实对于任何事物都一样。其次是你要主动获取高价值的信息，比如使用 RSS 订阅<a href="https://www.zhihu.com/question/19580096">高价值的内容</a>。</p><p>长期获取高价值的网络信息将会提升你对网络信息的信任度，也是间接地减少鲜活性效应对你的影响。</p><h3 id="走出-comfort-zoom，自己解决问题"><a href="#走出-comfort-zoom，自己解决问题" class="headerlink" title="走出 comfort zoom，自己解决问题"></a>走出 comfort zoom，自己解决问题</h3><p>我们知道，遇到一个比较复杂的问题，如果身旁有个大神，可能只需要他的轻轻点拨我们便可以豁然开朗。但是这个“轻轻点播”来自于大神丰富的知识积累。如果我们要自己探索出这个“点拨”，所花费的时间将比这一句简单的提问多得多。<br>刘未鹏大大写过一篇<a href="http://mindhacks.cn/2009/07/06/why-you-should-do-it-yourself/">《遇到问题为什么应该自己解决》</a>，里面解释了遇到问题自己解决的好处:</p><ol><li><p>为了解决一个技术问题，你踏遍互联网，翻了若干教程、网站、书籍，最终解决了这个问题的同时还知道了以后遇到类似的问题该到哪儿最快最有效地找到参考，你还知道了哪些网站是寻找这个领域最有价值信息的地方，你还知道了哪些书是领域内最经典的书，说不定你在到处乱撞的过程中还会遇到其他若干意想不到的收益。</p></li><li><p>为了解决一个内存泄漏的 bug，你学习了一堆底层知识、了解了一堆调试工具、学习了若干 wikipedia 页面，表面上看来，仅仅为了解决这一个小 bug 你的时间花销未免太大了点，然而关键就在于，它的收益远远不止于解决了这一个小 bug，下次你遇到任何类似的 bug 的时候就能够哐当两下就解决之了。</p></li></ol><blockquote><p>困难的路越走越容易，容易的路越走越难。</p></blockquote><p>这一点与我们的主题“如何突破环境对人的制约”有什么关系呢？前文提到，在一个良好的环境中，你很可能会有一个大神可以依赖，为了节约时间以及避免踩坑，许多技术方案都交由更有经验的大神来定夺。在这种情况下，你其实失去了不少的锻炼机会。而一个较差的环境由于没有大神坐镇，很多时候复杂的需求你都要顶着头皮上，整个解决方案都要自己想，这无形中会对你形成很多的锻炼。毕竟，解决问题的能力是最关键的。</p><h3 id="勤于思考"><a href="#勤于思考" class="headerlink" title="勤于思考"></a>勤于思考</h3><p>这一点就很泛了，前三点实际上都可以归结为这一点。实际上，我也是近期才意识到思考的重要性，我还发了一条朋友圈说突然醒悟自己除了失恋，考试和工作，已经很久没有思考了。这其实是很糟糕的。苏格拉底说：</p><blockquote><p>未经检视的人生是不值得活的。</p></blockquote><p>这是在告诉我们，要经常思考，要经常反省自己啊！前文提到的克里斯蒂娜也跟我说，她天天都写日记，不仅可以记录当天的快乐与失落，还可以反思自己当天处理事情的得与失。</p><h3 id="额外附赠"><a href="#额外附赠" class="headerlink" title="额外附赠"></a>额外附赠</h3><p>想办法去到一个更好的环境，重复以上过程:D</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体而言，我们想要突破环境的制约，需要付出的努力自然是要比那些已经处在更好的环境中的人更多的。更何况那些人处在更好环境中，很可能是因为本身也很努力，这就使得突破这个限制更加困难。但这些都是值得的。</p><p>最后我要提醒一点，不要产生超出自身环境太多的期望，假设你作为一个普通家庭的孩子，想要在TG从政，目标做到市长，那基本是不可能的兄弟。人生不是百米冲刺，其实是场接力赛。</p><p>That’s it.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;笔者本科毕业后进入一家初创公司。大家都知道，对于搞技术的同学来说，刚毕业就进入初创公司（相较于大公司）有着显而易见的弊端，其一是初创公司没有
      
    
    </summary>
    
      <category term="Caren how" scheme="http://laijiawen.com/categories/Caren-how/"/>
    
    
      <category term="思考" scheme="http://laijiawen.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>如何培养自信</title>
    <link href="http://laijiawen.com/posts/how-to-grow-confidience/"/>
    <id>http://laijiawen.com/posts/how-to-grow-confidience/</id>
    <published>2018-09-25T20:04:30.000Z</published>
    <updated>2020-11-10T02:01:37.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来谈一个老生常谈的话题,<strong>如何培养自信</strong>。</p><p>大家小时候都看过《读者》、《意林》等等杂志（都是积累作文素材的好杂志啊），其中关于如何培养自信的文章有很多，我大体记得一些文章中的建议：</p><ol><li>时常保持微笑。</li><li>抬头挺胸。</li><li>与人交谈时保持眼神交流。</li><li>乐于助人</li></ol><p>这些建议有时候是有效的。因为人的大脑有时候会被自己的动作欺骗，久而久之，你骗多了你的大脑，你的大脑就相信了。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Fake_it_till_you_make_it">Fake it till you make it.</a></p></blockquote><p>但我今天要说的不是这种欺骗大脑的方法，而是一种让你从一点一滴的小成功开始，逐步培养自信的方法。这个方法就是 <strong>培养一种“我能做到”的感觉</strong>。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>这句话我是从一个 <a href="https://www.youtube.com/watch?v=0KV9NrSDClc">youtube 视频</a>看到的，这个视频介绍了知名 YouTuber Chris Heria 如何从当年的瘦小小子变成如今在 youtube 上有着 100 多万关注量的健身大神。我看过 Chris Heria 不少的视频，因而对这个视频有更深的感触。视频中说到他在 20 来岁的时候，希望</p><blockquote><p>Develop a feeling of possible, and I want becomes I will.<br>译：培养一种“我能做到”的感觉，把“我想”变成“我可以”</p></blockquote><p>这句话想要达到的状态，恰好与我先前了解到的一个心理学概念———<a href="https://wiki.mbalib.com/wiki/%E4%B9%A0%E5%BE%97%E6%80%A7%E6%97%A0%E5%8A%A9">习得性无助</a>，所形容的状态完全相反。</p><blockquote><p>习得性无助是指人或动物接连不断地受到挫折，便会感到自己对于一切都无能为力，丧失信心，陷入一种无助的心理状态。</p></blockquote><p>在我刚接触到<strong>习得性无助</strong>这个概念的时候，就恍然发现自己正逐渐陷入这样的习得性无助状态。举几个的例子，室友新买了吉他，于是我也想要学一下，于是搜搜教程，找到了 youtube 上一个《15 天入门吉他》的视频，兴致勃勃地看了三四天，只学会了两三个和弦就放弃（忘记）了；大二开始的时候开始健身，至今已近两三年了，刚开始进展还行，但这一两年都没什么效果了；经常粗略的制定当日计划，往往会在执行过程中发现更急需处理的 bug 或来了新的需求，导致几乎计划都没有成功完整执行过。</p><p>You know, 人只有在发现了问题之后才能改正问题。在了解习得性无助之前我并不觉得以上的行为有什么问题。没有继续学吉他只是因为我当时是三分钟热度，并非真的想学；健身没有效果只是因为在平台期，慢慢来不要紧；难以完整执行计划是因为我是一个“<a href="https://www.16personalities.com/ch/esfp-%E4%BA%BA%E6%A0%BC">表演型人格</a>”的人，这一类人天生不擅长规划。一件件实际上算是失败了的事情，我的潜意识都找到了一个良好的理由。相信我不是个例，作为读者的你应该有相似的体验。</p><p>回到主题，前面说到，这句话给我带来这么大的触动的原因在于，它和<strong>习得性无助</strong>这个概念一起，引起了我对自己的整个行为模式、行事习惯的反思。前者表达的是“我能做到”的自信，而后者则是“我什么都做不好”的深渊，而我正逐渐陷入后者。因而我必须做出一些改变，我必须像 Chris heria 一样，develop a feeling of possible.</p><h2 id="如何-Develop-a-feeling-of-possible"><a href="#如何-Develop-a-feeling-of-possible" class="headerlink" title="如何 Develop a feeling of possible"></a>如何 Develop a feeling of possible</h2><p>我们都有着自己的工作，自然不可能像Chris Heria一样每天花数小时健身，我们得摸索自己的方法。我的方法很简单，<strong>从完成好生活中的小事开始，逐渐计划长远的事情</strong>。</p><ol><li>列下今天的to-do list，可以不多，但保证全部完成。</li><li>健身的时候，在某组动作的开始给自己定下一个稍难的目标，尽全力也把它做完。</li><li>平时要花20分钟做完的事情，尝试限时16分钟。</li><li>…</li></ol><p>简而言之就是在生活的各个角落都可以给自己定下略有挑战的目标，接着去完成它。这个方法我刚开始使用，感觉有一定效果。如今我感觉每天精力充沛，计划事项都能如期完成，计划看完的《JavaScript语言精粹》和《JavaScript设计模式》也快看完了。当然作为一个理科生，我知道我个人的见证叙述不能得出有说服力的结论，我自然也没有做过对比实验来证明这个方法可行。</p><p>But it just works for me.</p><p>希望能给作为读者的你也有所启发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天来谈一个老生常谈的话题,&lt;strong&gt;如何培养自信&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;大家小时候都看过《读者》、《意林》等等杂志（都是
      
    
    </summary>
    
      <category term="Caren how" scheme="http://laijiawen.com/categories/Caren-how/"/>
    
    
      <category term="思考" scheme="http://laijiawen.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>如何避免被洗脑(上)</title>
    <link href="http://laijiawen.com/posts/how-to-avoid-being-brainwashed-part-1/"/>
    <id>http://laijiawen.com/posts/how-to-avoid-being-brainwashed-part-1/</id>
    <published>2018-09-23T20:53:27.000Z</published>
    <updated>2020-11-10T02:01:37.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间工作 <del>需求不饱和</del> 工作效率较高，于是可以在上班时间抽空看看书。由于一直对心理学感兴趣，便下载了一本《影响力》来看。这本书咋听中文翻译，像是管理学的书籍，类似教你怎么扩大自己的影响力之类的，但翻阅一下目录就知道不是这么回事。本书原作名是《Influence: The Psychology of Persuasion》,其实讲的是你是如何被说服(洗脑)的。原本我只是带着随便翻翻的心态看了一下，但我确实被本书震撼到了，震撼的原因有2点：</p><ol><li>本书介绍的六个原理确实非常有效。绝大多数人都应该有过深刻的体会。</li><li>本书说理的逻辑十分严谨。几乎所有在我阅读过程中产生的疑惑，在后文都被作者解答了。一般的书，说理的时候是这样A-&gt;B，这个逻辑正常人都懂，稍微好一点的书分析到了A-&gt;B-&gt;C，而这本书可能有些章节就让你有 A-&gt;B-&gt;C-&gt;D-&gt;E的感觉，醍醐灌顶。在你本以为这个原理大概就这样了，后面应该都是同样的例子了的时候，他又会提出关于该原理的新的问题和假设，并用实验验证。</li></ol><p>本文分别介绍《影响力》一书中讲述的六个影响力武器，并加上我自己对于它们的体会。分别有对比原理、互惠原理、一致性原理、社会认同原理、喜好原理、权威原理、短缺原理。作者讲述的逻辑是这样的：</p><ol><li>先用一个亲身经历或者邻居等等的例子，来说明这个原理起了效果。</li><li>分析它是怎么起的效果。</li><li>该原理还可以被如何运用</li><li><strong>如何保护自己不被这个原理给欺骗</strong>。</li></ol><h2 id="对比原理"><a href="#对比原理" class="headerlink" title="对比原理"></a>对比原理</h2><p>这个原理十分好理解，不需赘述。简而言之就是，如果两件东西很不一样，我们往往会认为他们的差别比实际的更大。如果我们拿起一个很轻的东西，再拿一个重的东西，就会觉得后者比单独拿起来时还要重；如果我们在酒吧里刚认识一个很漂亮的女生，又遇到一个平平无奇的女生，后面这个女生就会显得更缺乏吸引力。</p><h3 id="常见情形"><a href="#常见情形" class="headerlink" title="常见情形"></a>常见情形</h3><ol><li><p>购物 1。假设你已经买了贵的东西，很容易会继续买便宜很多的东西，即使便宜的东西按照你平时的标准也不便宜。以我亲身经历来说，我上次去看牙，因为要做的项目很多，那个小姐姐就先给我介绍了最贵的种牙项目，8800 块钱，我说 ok 之后。我注意到我对于价格认知已经发生了变化，后面挑选的相对便宜（但仍旧很贵）的牙冠、补牙等等项目，我都没有太多犹豫了。但我回头细想，特么的我买个很喜欢的耳机 2000 块都不舍得，要等到双十一买。做个牙冠居然花了我 3500.</p></li><li><p>购物 2。房地产公司往往会保留一两套很破但价格很高的房子。他们不是用来卖的，是用来给顾客看的。这样相比之下，那些公司真正想要卖掉的房子就会显得格外有吸引力。</p></li></ol><h2 id="互惠原理"><a href="#互惠原理" class="headerlink" title="互惠原理"></a>互惠原理</h2><p>互惠原理认为，我们应该尽量以相同的方式报答他人为我们所做的一切。互惠原理之所以可以成为有效说服他人的工具，一个重要的原因就在于它所蕴藏的巨大力量，它可以让我们产生多余的负债感。</p><blockquote><p>值得注意的是，在这个过程中双方的力量极不平衡，因为所有真正的选择权都掌握在乔的手中，他选择了最初给予恩惠的形式，也选择了回报恩惠的形式。</p></blockquote><h3 id="“拒绝——退让”策略"><a href="#“拒绝——退让”策略" class="headerlink" title="“拒绝——退让”策略"></a>“拒绝——退让”策略</h3><p>这是另一种方法可以利用互惠原理让他人答应自己的请求，这种方式更为巧妙。从广义上讲，互惠原理说的是如果一个人对我们采取了某种行为，我们应该以类似的行为去回报。而这个原理产生的另一个结果是，如果他人对我们做出了让步，我们也有义务作出让步。举一个例子，</p><blockquote><p>有一天我正在街上走着，迎面过来一个十一二岁的男孩。他先做了一番自我介绍，然后问我要不要买几张周六晚年度童子军杂技表演的票， 5 块钱一张。我对这种事情向来没什么兴趣，因此婉言谢绝了。“哦，既然你不想买杂技表演的票，”他说，“那要不要买几块我们的大巧克力？只要一元钱一块哟。”我买了两块，巧克力；（b）我不喜欢随便花钱；（c）我站在那里，手里拿着两块他的巧克力；（d）他拿着我的两块钱走掉了</p></blockquote><p>通过这个原理我们可以使用一个将这个退让的过程利用起来，成为一种说服的技巧。 这种技巧简称<strong>“拒绝——退让”策略</strong>： 假设你想让我答应你的一个请求，有一个方法可以大大提高你的成功率：你先向我提出一个比较大的，极有可能会被拒绝的请求，然后当我拒绝了这个请求之后你再提出一个比较小一些的、你真正感兴趣的请求。如果你能很有技巧的提出第二个请求，就会让我认为这第二个请求是你做出的第一个让步，因而让我觉得自己也有义务做出相应的让步。我现在就有这样一个机会，即同意你的第二个请求。注意一点，最初提出的请求不可以太极端太无理。另外需要注意的是，这个策略也利用了对比原理。</p><h4 id="拒绝退让策略的弊端"><a href="#拒绝退让策略的弊端" class="headerlink" title="拒绝退让策略的弊端"></a>拒绝退让策略的弊端</h4><ol><li>因为被迫做出妥协的怀恨在心，因而拒绝履行口头做出的承诺。</li><li>可能会对那个工于心计使用“拒绝——退让”的人失去信任，决定以后不再跟他打交道。</li></ol><h4 id="拒绝退让策略能起作用的根本原因"><a href="#拒绝退让策略能起作用的根本原因" class="headerlink" title="拒绝退让策略能起作用的根本原因"></a>拒绝退让策略能起作用的根本原因</h4><p>使得对方对协议的达到负有更多的<strong>责任感</strong>和更高的<strong>满意度。</strong></p><ul><li>责任：是我使得对方做出了让步，因而我对最后的谈判结果负有更多责任。</li><li>满意度：如果一个协议的达成是通过对方的让步得到的，我们对谈判的最后的结果会最为满意。</li></ul><h3 id="如何保护自己"><a href="#如何保护自己" class="headerlink" title="如何保护自己"></a>如何保护自己</h3><ol><li>不要一味的拒绝别人的善意，因为有时候确实是善意而不是套路。</li><li>判断他人最初给予我们的恩惠是不是我们想要的。</li></ol><h3 id="常见情形-1"><a href="#常见情形-1" class="headerlink" title="常见情形"></a>常见情形</h3><ol><li>路边的假和尚，送你一个护身符，然后募捐。</li><li>免费试用。使用之后产生了负债感，就试图通过买他们的商品来消除。今天才因为尝了一口酸奶而花了12块买了两瓶，原本只是打算买咖啡的:)</li></ol><h2 id="一致性原理"><a href="#一致性原理" class="headerlink" title="一致性原理"></a>一致性原理</h2><blockquote><p>几名加拿大的心理学家曾做过一项实验，结果在赌马者身上发现了一个有趣的现象，那就是赌马者一旦下了赌注，他们立刻对自己所买的那匹马的信心大增。其实这批马获胜的概率一点也没有改变，马还是原来那匹马，赛道还是原来那条赛道，赛场还是原来那个赛场。但在这些赌马者的眼中，一旦下了赌注之后，这批马获胜的希望就大大地提高了。虽然这种转变乍见之下有点让人迷惑不解，但其成因却与一种常见的社会影响力的武器有着密切的关系。像其他影响力的武器一样，这种武器也深藏在我们当中，不漏声色地指导我们的行为。简单地说，这种武器就是一种要与我们过去的所作所为保持一致的愿望。一旦我们做出了某个决定，或选择了某种立场，就会面对来自个人和外部的压力迫使我们的言行与它保持一致。在这种压力之下，我们会采取某种行为以证明我们之前所做的决策.</p></blockquote><p>如果你对某件事情做出了承诺，或者持有了某种看法，你将会在未来对此保持一致。想法的生根发芽就是这么来的。</p><h3 id="承诺是关键"><a href="#承诺是关键" class="headerlink" title="承诺是关键"></a>承诺是关键</h3><p>作者通过数个例子说明了一致性原理对人类行为的巨大影响力，那么我们如何去使用这种力量呢？<strong>承诺</strong>是关键。如果我能让你做出承诺（也就是选择某种立场），我就为你下一步机械的、无意识的保持一致的行为准备好了舞台。一旦选择了某种立场，固执的坚持这个立场是一种自然趋势。</p><p>这个承诺需要有几个重要的特征，主动性、公开性、需要付出更多的努力才能做到、以及内心的选择。最重要的是最后一点。这一点对于儿童教育有着重要意义，当我们想要孩子们真正相信一件事情时，不应该去贿赂他们或威胁他们，而应该想办法让孩子们相信他们的做法是对的。对做父母的人来说，挑选一个恰如其分的理由可不是一件容易的事情，但这个努力是会有回报的。这个理由很可能就是短暂顺从和长期承诺之间的分界线。</p><h3 id="如何保护自己-1"><a href="#如何保护自己-1" class="headerlink" title="如何保护自己"></a>如何保护自己</h3><p>使用两种信号提醒自己当我们意识到自己落入了某种圈套，不得不做出自己不想做的事情时，问自己<br><strong>如果时光倒流，我还会做出同样的选择吗？</strong></p><h3 id="常见情形-2"><a href="#常见情形-2" class="headerlink" title="常见情形"></a>常见情形</h3><ol><li>打电话推销，先问你 how’s your day. 你说还不错，然后他后面的推销会更加顺利。（但我感觉在中国不太 work）</li><li>制定一个目标，并把它写下来，不管这个目标是什么，重要的是你要把它写下来。这个方法也可以用在企业管理，让员工写下这个月努力的方向。并挂在显眼的位置。</li><li>卖东西时，先虚报一个较低的价格， 让客户产生想买的欲望。到后面再通过一些策略把价格调回去。“忘记算xx了，不好意思”</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文先描述了前三个影响力武器：对比原理、互惠原理以及一致性原理，并说明了如何避免他人使用这些武器对我们造成影响。本来想一次总结完，但本书内容确实丰富，没有办法一篇文章讲完，甚至每章都可以用一篇文章来讲述。故我们还是分为上下两部份分开讲好了。<br>That’s it.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间工作 &lt;del&gt;需求不饱和&lt;/del&gt; 工作效率较高，于是可以在上班时间抽空看看书。由于一直对心理学感兴趣，便下载了一本《影响力》来
      
    
    </summary>
    
      <category term="Caren how" scheme="http://laijiawen.com/categories/Caren-how/"/>
    
    
      <category term="心理学" scheme="http://laijiawen.com/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="读书笔记" scheme="http://laijiawen.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
